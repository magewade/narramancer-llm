import os
from dotenv import load_dotenv
from langchain_mistralai import ChatMistralAI
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables.history import RunnableWithMessageHistory
import sqlalchemy
import re
from langchain_community.chat_message_histories import SQLChatMessageHistory


# Загрузка переменных окружения
load_dotenv()


# Класс для управления чат-ботом D&D
class DNDChatbot:
    def __init__(self):
        # Получение API ключа
        self.api_key = os.getenv("MISTRAL_API_KEY")

        # Инициализация языковой модели
        self.llm = ChatMistralAI(
            model="mistral-large-latest",
            temperature=0.7,  # Немного повышенная температура для креативности
        )

        # Системный промпт для D&D бота
        self.system_prompt = """Ты Narramancer - мастер для настольной ролевой игры, похожей на Dungeons & Dragons.
                                Твои задачи:
                                - Создавать увлекательные и динамичные сюжетные повороты
                                - Описывать окружение, персонажей и события
                                - Помогать игрокам погрузиться в мир приключений
                                - Следить за правилами и механикой игры
                                - Игрок начинает с введения своего персонажа, если он начинает с чего-то другого, предложи ему создать персонажа
                                - На основании описания персонажа САМ составь лист характеристик и покажи его игроку
                                - Характеристики влияют на возможности персонажа и его поведение в игре
                                ХАРАКТЕРИСТИКИ:
                                    1. **Сила** (Strength) - физическая мощь и выносливость.
                                    2. **Ловкость** (Dexterity) - гибкость и рефлексы.
                                    3. **Телосложение** (Constitution) - здоровье и живучесть.
                                    4. **Интеллект** (Intelligence) - умственные способности и знания.
                                    5. **Мудрость** (Wisdom) - интуиция и внимание к деталям.
                                    6. **Харизма** (Charisma) - лидерские качества и убедительность.
                                - Каждая характеристика может быть установлена от 1 до 20.
                                - Также есть параметр HP, который определяет количество жизней персонажа.
                                ХП=Базовый показатель+Телосложение×3+Сила×1.5+Ловкость×1.2+Интеллект×0.5+Мудрость×0.5+Харизма×0.5
                                - При атаке врагов, тебе надо вычитать из HP количество урона и задать хит, если HP<0, то игрок погибает
                                - Игрок может лечиться зельями или магией, но у них есть ограничения, иногда могуть появится плохие эффекты (можешь предложить кидать кубик)
                                - В начале игры напиши для игрока список характеристик, а также его имя, расу, класс, оружие, внешность, кратко предысторию, предполагаемые имеющиеся предметы и магию
                                - Исходя из описания, ты можешь решать сколько у игрока имеется с собой монет - от 0 до 1000 
                                - Монеты тратятся в тавернах, магазинах или их могут украсть
                                - Ты не решаешь за игрока, что ему делать и говорить. Каждый раз, когда история подводит к выбору, предложи несколько вариантов, но обязательно укажи, что игрок может предложить свой вариант.
                                ВАЖНЫЕ ПРАВИЛА БРОСКОВ КУБИКОВ:
                                    1. Когда в тексте встречается специальный формат [roll:XdY], это означает необходимость броска кубика.
                                    2. X - количество кубиков, Y - количество граней.
                                    3. Примеры: [roll:1d20] - один бросок 20-гранного кубика.
                                    4. НЕ ПОДСТАВЛЯЙ РЕЗУЛЬТАТ БРОСКА САМ.
                                    5. ВСЕГДА ОСТАВЛЯЙ МЕТКУ [roll:XdY] ДЛЯ ИГРОКА.
                                    6. Кубик бросается один и на одну ситуацию, на проверку одной характеристики или проверку иницаивативы.
                                    7. Для врагов игрок бросать кубики НЕ ДОЛЖЕН, решай что делают враги сам
                                    8. Игрок не может бросить больше 1 кубика за раз, так что лучше не предлагает бросить несколько кубиков в один ход
                                - БРОСКИ КУБИКОВ НЕ ДОЛЖНЫ БЫТЬ ПРИНИМАНЫ, ЕСЛИ ОНИ НЕ ОТНОСЯТСЯ К ПРОВЕРКЕ, ИНИЦИАТИВЕ, БОЕВЫМ ДЕЙСТВИЯМ ИЛИ ДРУГИМ МЕХАНИКАМ ИГРЫ. НЕ ПРОГРАММИРУЙ КУБИКИ ДЛЯ ОБЫЧНОГО ПРЕДСКАЗАНИЯ СИТУАЦИИ, КАК "ЧТО ЖДЕТ НА ДОРОГЕ". В ТАКИХ СЛУЧАЯХ ПРОСТО ОПИШИ СИТУАЦИЮ.
                                - НЕ ИНТЕРПРЕТИРУЙ БРОСКИ КУБИКОВ ДЛЯ РЕШЕНИЯ, КУДА ИДТИ, если этого не требует конкретная ситуация.
                                  Если выбросить кубик нужно для решения, как продвигается сюжет (например, проверка инициативы, боевой бросок и т.д.), тогда подожди получения результата.
                                - Когда нужно бросить кубик, приостанавливай действие, не давай игроку решать что делать, пока он не бросил кубик
                                - НЕ предлагай варианты развития событий или действий до получения результата броска.
                                - После броска кубика продолжи историю в зависимости от результата: значение кубика + (логично близкая характеристика персонажа - 10 / 2) должны быть больше 10 (успех) - не пиши полную формулу игроку, просто после результата броска проговоривай - результат плюс бонус модификации
                                - Игрок должен бросать кубик только за себя
                                - Игрок должен говорить за себя. Не говори за игрока! Дай ему решить самому как он относится к той или иной ситуации
                                - За решения и действия NPC решения принимаешь ты
                                - Не говори от лица игрока, игрок говорит за себя
                                - Будь справедливым и создавай захватывающую историю.
                                - Не будь клишированным, придумывай неожиданные сюжетные повороты и уникальных персонажей с серой моралью. НЕ все персонажи должны соглашаться или идти на поводу у игрока, некоторые могут грубить, насмехаться и быть неприятными личностями с серой моралью
                                - Интрига и перчинка никогда не помешают
                                - Попытайся влезть в лимит в 4000 символов за одно сообщение (можно меньше, но не больше).

                                Веди себя как опытный рассказчик и организатор приключений."""

        # Словарь для хранения истории чатов
        self.chat_histories = {}

        # Создаем директорию для базы данных, если она не существует
        os.makedirs("chat_histories", exist_ok=True)

        # Создание цепочки обработки
        self.chain = self.create_chain()

    def start_new_game(self, session_id: str):
        """Метод для начала новой игры с очисткой истории"""
        # Получаем текущую историю
        history = self.get_session_history(session_id)

        # Очищаем историю
        history.clear()

    def create_chain(self):
        """Создание цепочки обработки с историей сообщений"""
        # Создание шаблона чата
        prompt = ChatPromptTemplate.from_messages(
            [
                ("system", self.system_prompt),
                MessagesPlaceholder(variable_name="chat_history"),
                ("human", "{player_input}"),
            ]
        )

        # Основная цепочка с добавлением переменной roll
        from langchain_core.runnables import RunnablePassthrough

        base_chain = (
            RunnablePassthrough.assign(roll=lambda x: x.get("roll", ""))
            | prompt
            | self.llm
            | StrOutputParser()
        )

        # Создание цепочки с историей
        return RunnableWithMessageHistory(
            base_chain,
            self.get_session_history,
            input_messages_key="player_input",
            history_messages_key="chat_history",
            additional_variables=[
                "roll"
            ],  # Добавляем roll как дополнительную переменную
        )

    # Изменим взаимодействие с кубиками в методе interact

    def interact(
        self, player_input: str, session_id: str = "default_session", roll: str = None
    ):
        """Взаимодействие с чат-ботом с обработкой бросков кубика"""
        try:
            # Проверка наличия формата броска кубика
            roll_match = re.search(r"\[roll:(\d+)d(\d+)\]", player_input)

            if roll_match:
                # Извлечение параметров броска
                num_dice = int(roll_match.group(1))
                dice_sides = int(roll_match.group(2))

                # Если результат броска не передан, генерируем приглашение
                if roll is None:
                    return f"🎲 Тебе нужно бросить {num_dice}d{dice_sides}. Нажми на кнопку броска!"

                # Если результат броска передан, подставляем его
                roll_result = int(roll)

                # Оставляем метку как есть
                modified_input = player_input  # Не заменяем метку

                # Выполнение запроса с сохранением истории
                response = self.chain.invoke(
                    {"player_input": modified_input, "roll": str(roll_result)},
                    {"configurable": {"session_id": session_id}},
                )

                return response

            else:
                # Обычный режим без броска
                response = self.chain.invoke(
                    {"player_input": player_input, "roll": ""},
                    {"configurable": {"session_id": session_id}},
                )
                return response

        except Exception as e:
            return f"Произошла ошибка: {e}"

    def get_session_history(self, session_id: str):
        """Получение истории сообщений с использованием SQLite"""
        engine = sqlalchemy.create_engine("sqlite:///database/chat_history.db")
        return SQLChatMessageHistory(session_id=session_id, connection=engine)
